/*
              // REACT STARTUP PROCESS ///
    1. YOU RUN THIS LINE OF CODE: const rootElement = document.getElementById('root');
THIS LINE OF CODE GETS A REFERENCE TO A DIV WITH THE ID OF ROOT.

    2. YOU RUN THIS LINE OF CODE: const roo = createRoot(rootElement);
THIS TELLS REACT THAT YOU WANT TO TAKE CONTROL OF THAT DIV AND RENDER OUR APP TO IT.

    3. YOU ARE TELLING REACT THAT YOU WANT TO RENDER YOUR APP COMPONENTS AND SHOW ALL JSX, TURN IT INTO HTML, AND SHOW IT IN THE ROOT DIV.
YOU RUN THIS LINE OF CODE: root.render(<App />);
------------------------------------------------------------------------------------------------------------------------
              //  WHAT ARE useState FUNCTIONS? //
THE useState IS A FUNCTION THAT WORKS WITH REACT'S state SYSTEM.
STATE IS LIKE A VARIABLE IN REACT.
WE MAKE use OF STATE TO STORE DATA THAT IS GOING TO CHANGE OVER TIME AS THE USER INTERACTS WITH THE APP.
ANY TIME WE UPDATE state, REACT IS GOING TO AUTOMATICALLY RE-RENDER THE COMPONENT THAT USES THAT STATE ON THE SCREEN.

           IN THE TRANSLATING APP EXAMPLE, THE APP HAD THREE PIECES OF DATA THAT CHANGED.
       1. THE TEXT THAT THE USER WAS TYPING IN THE INPUT FIELD.
       2. THE LANGUAGE THAT THE USER SELECTED FOR TRANSLATION.
       3. THE RESULT OF THE TRANSLATION.

   SO WE ARE ABLE TO FIND A SINGLE CALL TO THE useState FUNCTION TO SET UP EACH OF THESE PIECES OF DATA.
1. THE FIRST CALL TO useState SETS UP state SYSTEM AND SAYS THAT WE'RE GOING TO HAVE SOME KIND OF SELECTED LANGUAGE THAT IS GOING TO CHANGE OVER TIME.
    EX: const [language, setLanguage] = useState("es");
2. THE SECOND CALL TO useState SETS UP state SYSTEM AND SAYS THAT WE'RE GOING TO HAVE SOME KIND OF TEXT THAT IS GOING TO CHANGE OVER TIME.
    EX: const [text, setText] = useState("");
3. THE THIRD CALL TO useState SETS UP state SYSTEM AND SAYS THAT WE'RE GOING TO HAVE SOME KIND OF TRANSLATED TEXT THAT IS GOING TO CHANGE OVER TIME.
    EX: const [translated, setTranslated] = useState("");
------------------------------------------------------------------------------------------------------------------------
             // HOW DID THE TEXT GET TRANSLATED TO ANOTHER LANGUAGE? //
TWO PIECES OF DATA, THE ACTUAL TEXT FROM THE INPUTS AND THE SELECTED LANGUAGE INTO THE TRANSLATE COMPONENT.
THAT COMPONENT WAS SETUP TO WATCH FOR THOSE TWO VALUES TO CHANGE, AND WHEN THEY DID, IT WAS GOING TO MAKE A REQUEST TO THE GOOGLE TRANSLATE API.
ONCE THE TRANSLATE COMPONENT GOT A RESPONSE FROM THE API AND THEN DISPLAYED THE RESULT TO THE USER ON THE SCREEN.
------------------------------------------------------------------------------------------------------------------------
        TO GENERATE A NEW PROJECT WITH REACT, YOU RUN THIS LINE OF CODE:
        npX create-react-app <name of your project>

        YOUR PROJECT WILL BE INSIDE A NEW DIRECTORY WITH THE SAME NAME AS YOUR PROJECT.
        TO CHANGE INTO THAT DIRECTORY YOU RUN THIS LINE OF CODE:
        cd <name of your project>

        ONCE INSIDE THE PROJECT DIRECTORY, YOU CAN RUN THE FOLLOWING LINE OF CODE:
        npm start

        TO VIEW YOUR PROJECT IN THE BROWSER, YOU CAN OPEN localhost:3000 TO VIEW IT IN THE BROWSER.

        IF YOU EVER WANT TO STOP THE SERVER, YOU CAN PRESS CTRL + C IN THE TERMINAL.
------------------------------------------------------------------------------------------------------------------------
            // WHAT ARE WE RUNNING IN OUR TERMINAL? & WHAT ARE ALL THE FILES ABOUT? //
SOME FILES IN OUR PROJECT CONTAIN: index.js, App.js, reportWebVitals.js. THOSE ARE FILES THAT CONTAIN JSX CODE THAT A BROWSER DOESN'T KNOW HOW TO EXECUTE.
THE THING THAT IS RUNNING INSIDE OF OUR TERMINAL IS REFERRED TO AS A DEVELOPMENT SERVER.
THE DEV SERVER RUNS A COUPLE OF DIFFERENT TOOLS INTERNALLY TO AUTOMATICALLY TAKE ALL THESE DIFFERENT FILES AND TAKE THE JSX INSIDE THEM AND TURN THEM INTO NORMAL JAVASCRIPT THAT A BROWSER CAN EXECUTE.
THAT TOOL IS CALLED BABBLE.
ANOTHER TOOL RUNNING INSIDE THE DEV SERVER AS WELL IS CALLED WEBPACK. THAT TOOL TAKES ALL OF OUR FILES AND KIND OF MASHES THEM TOGETHER INTO ONE FILE CALLED BUNDLE.JS.
WHEN FIRST ACCESSING OUR PROJECT IN THE BROWSER, THE BROWSER MAKES A REQUEST TO THE DEV SERVER AND ASKS FOR THE HTML FILE,
THE BROWSER LOADS UP THE HTML AND MAKES A SECOND REQUEST TO THE DEV SERVER AND ASKS FOR THE BUNDLE.JS FILE.

WHEN STARTING A REACT PROJECT, YOU DON'T NEED ALL THE FILES THAT ARE IN THE PROJECT DIRECTORY IN ORDER TO RUN THE PROJECT.

IN FACT, ONLY ABOUT 5 OF THEM ARE ACTUALLY REQUIRED TO RUN A REACT APPLICATION:
1.index.js - FIRST FILE THAT GETS EXECUTED WHEN OUR APP RUNS.
2.index.html - SKELETON FOR THE REACT APP.
3.package.json -  LISTS DEPENDENCIES OUR APP NEEDS.
4.package-lock.json -  LISTS EXACT VERSIONS OF DEPENDENCIES THAT ARE INSTALLED.
5.node_modules -  FOLDER THAT CONTAINS ALL OF OUR DEPENDENCIES.

WHEN THE REACT PROJECT IS CREATED WE GET A LOT OF ADDED FILES ON TOP JUST AS KIND OF A CONVENIENCE TO MAKE DEVELOPING OUR APP A BIT EASIER IN THE FUTURE.
------------------------------------------------------------------------------------------------------------------------
              // PRINTING OUT JAVASCRIPT VARIABLES IN JSX //
WE MOST OFTEN USE CURLY BRACES TO SHOW STRINGS OR NUMBERS JUST BECAUSE THOSE ARE THE MOST COMMON DATA TYPES THAT WE WANT TO DISPLAY TO USERS.
REACT TREATS BOOLEANS, NULLS, UNDEFINED, AND ARRAYS IN A SLIGHTLY UNEXPECTED WAY.
THE ABSOLUTE GOTCHA IS IF YOU'RE GOING TO TRY TO PRINT OUT AN OBJECT, REACT WILL THROW OUT AN ERROR AND NOTHING WILL BE SHOWN ON THE SCREEN.
------------------------------------------------------------------------------------------------------------------------
              // SHORTHAND JS EXPRESSIONS //
    EXAMPLE FOR WRITING OUT LOCAL TIME:
function App() {
const date = new Date();
const time = date.toLocaleTimeString();           // THIS IS A LOT OF CODE TO WRITE OUT THE TIME. IT CAN BE DONE WITHIN THE CURLY BRACES.

return <h1>{time}</h1>;
}

    EXAMPLE FOR WRITING OUT LOCAL TIME(SHORTHAND):
function App() {
return >h1>{new Date().toLocaleTimeString()}</h1>;     // RATHER THAN DECLARING TWO VARIABLES AHEAD OF TIME, YOU CAN ADD A NEW DATE OBJECT AND CALL THE ToLocaleTimeString METHOD ON IT.
}
------------------------------------------------------------------------------------------------------------------------
                // Quiz 1 Questions //
    1. What would the following component show on the screen?
    function App() {
      const favoriteColor = 'Blue';

      return <div>{favoriteColor}</div>
    }
ANSWER: A div with the text Blue inside of it.


    2. Imagine you're working on the following component:
    function App() {
      const age = 23;

      return <h5></h5>;
    }
    You want to show the age variable inside of the h5 element.  How would you update the JSX to do so?
ANSWER: <h5>{age}</h5>


    3. What would the following component display on the screen?
    function App() {
      const person = { name: 'Samantha' };

      return <div>{person}</div>;
    }
ANSWER: Nothing, React would throw an error because you Aare trying to show an object on the screen.
------------------------------------------------------------------------------------------------------------------------
               // Exercise Question 1 //
   Add your name to the  empty string on 4th line.
   Print the name variable in the h1 element.

   import React from 'react';

   function App() {
     const name = 'Cesar';

     return (
       <div>
         My name is:
         <h1>{name}</h1>
       </div>
     );
   }

   export default App;
------------------------------------------------------------------------------------------------------------------------

 */
